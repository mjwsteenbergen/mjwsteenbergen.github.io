(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const l of o)if(l.type==="childList")for(const r of l.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&n(r)}).observe(document,{childList:!0,subtree:!0});function s(o){const l={};return o.integrity&&(l.integrity=o.integrity),o.referrerpolicy&&(l.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?l.credentials="include":o.crossorigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function n(o){if(o.ep)return;o.ep=!0;const l=s(o);fetch(o.href,l)}})();const me="modulepreload",ge=function(e){return"/merry-christmas/"+e},F={},S=function(t,s,n){if(!s||s.length===0)return t();const o=document.getElementsByTagName("link");return Promise.all(s.map(l=>{if(l=ge(l),l in F)return;F[l]=!0;const r=l.endsWith(".css"),a=r?'[rel="stylesheet"]':"";if(!!n)for(let $=o.length-1;$>=0;$--){const d=o[$];if(d.href===l&&(!r||d.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${l}"]${a}`))return;const c=document.createElement("link");if(c.rel=r?"stylesheet":me,r||(c.as="script",c.crossOrigin=""),c.href=l,document.head.appendChild(c),r)return new Promise(($,d)=>{c.addEventListener("load",$),c.addEventListener("error",()=>d(new Error(`Unable to preload CSS for ${l}`)))})})).then(()=>t())},he=(e,t)=>{const s=e[t];return s?typeof s=="function"?s():Promise.resolve(s):new Promise((n,o)=>{(typeof queueMicrotask=="function"?queueMicrotask:setTimeout)(o.bind(null,new Error("Unknown variable dynamic import: "+t)))})},N="christmas-card-components",b={allRenderFn:!1,appendChildSlotFix:!1,asyncLoading:!0,asyncQueue:!1,attachStyles:!0,cloneNodeFix:!1,cmpDidLoad:!1,cmpDidRender:!1,cmpDidUnload:!1,cmpDidUpdate:!1,cmpShouldUpdate:!1,cmpWillLoad:!1,cmpWillRender:!1,cmpWillUpdate:!1,connectedCallback:!0,constructableCSS:!1,cssAnnotations:!0,cssVarShim:!1,devTools:!0,disconnectedCallback:!1,dynamicImportShim:!1,element:!1,event:!1,hasRenderFn:!0,hostListener:!1,hostListenerTarget:!1,hostListenerTargetBody:!1,hostListenerTargetDocument:!1,hostListenerTargetParent:!1,hostListenerTargetWindow:!1,hotModuleReplacement:!0,hydrateClientSide:!1,hydrateServerSide:!1,hydratedAttribute:!1,hydratedClass:!0,initializeNextTick:!1,invisiblePrehydration:!0,isDebug:!1,isDev:!0,isTesting:!1,lazyLoad:!0,lifecycle:!1,lifecycleDOMEvents:!1,member:!0,method:!0,mode:!1,observeAttribute:!0,profile:!0,prop:!0,propBoolean:!1,propMutable:!1,propNumber:!1,propString:!0,reflect:!1,safari10:!1,scoped:!0,scopedSlotTextContentFix:!1,scriptDataOpts:!1,shadowDelegatesFocus:!1,shadowDom:!0,shadowDomShim:!1,slot:!1,slotChildNodesFix:!1,slotRelocation:!1,state:!0,style:!0,svg:!0,taskQueue:!0,transformTagName:!1,updatable:!0,vdomAttribute:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!1,vdomListener:!0,vdomPropOrAttr:!0,vdomRef:!1,vdomRender:!0,vdomStyle:!0,vdomText:!0,vdomXlink:!1,watchCallback:!1};let I,D,ye=0,u=!1,Q=null,R=!1;const v=typeof window<"u"?window:{},h=v.document||{head:{}};v.HTMLElement||class{};const f={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},te=e=>Promise.resolve(e),se=(e,t,s,n)=>{},ve="sty-id",Ee="{visibility:hidden}.hydrated{visibility:inherit}",m=(e,t="")=>{if(performance.mark){const s=`st:${e}:${t}:${ye++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},Le=(e,t)=>performance.mark?(performance.getEntriesByName(e).length===0&&performance.mark(e),()=>{performance.getEntriesByName(t).length===0&&performance.measure(t,e)}):()=>{},Se=e=>{const t=p(e);if(!t)return;const s=t.$flags$,n=t.$hostElement$;return{renderCount:t.$renderCount$,flags:{hasRendered:!!(s&2),hasConnected:!!(s&1),isWaitingForChildren:!!(s&4),isConstructingInstance:!!(s&8),isQueuedForUpdate:!!(s&16),hasInitializedComponent:!!(s&32),hasLoadedComponent:!!(s&64),isWatchReady:!!(s&128),isListenReady:!!(s&256),needsRerender:!!(s&512)},instanceValues:t.$instanceValues$,ancestorComponent:t.$ancestorComponent$,hostElement:n,lazyInstance:t.$lazyInstance$,vnode:t.$vnode$,modeName:t.$modeName$,onReadyPromise:t.$onReadyPromise$,onReadyResolve:t.$onReadyResolve$,onInstancePromise:t.$onInstancePromise$,onInstanceResolve:t.$onInstanceResolve$,onRenderResolve:t.$onRenderResolve$,queuedListeners:t.$queuedListeners$,rmListeners:t.$rmListeners$,["s-id"]:n["s-id"],["s-cr"]:n["s-cr"],["s-lr"]:n["s-lr"],["s-p"]:n["s-p"],["s-rc"]:n["s-rc"],["s-sc"]:n["s-sc"]}},be=()=>{{const e=v.stencil=v.stencil||{},t=e.inspect;e.inspect=s=>{let n=Se(s);return!n&&typeof t=="function"&&(n=t(s)),n}}},Y=new WeakMap,ke=(e,t,s)=>{let n=A.get(e);n=t,A.set(e,n)},xe=(e,t,s,n)=>{let o=ne(t);const l=A.get(o);if(e=e.nodeType===11?e:h,l&&typeof l=="string"){e=e.head||e;let r=Y.get(e),a;r||Y.set(e,r=new Set),r.has(o)||(a=h.createElement("style"),a.innerHTML=l,a.setAttribute(ve,o),e.insertBefore(a,e.querySelector("link")),r&&r.add(o))}return o},Te=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,o=m("attachStyles",t.$tagName$),l=xe(s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);n&10&&(s["s-sc"]=l,s.classList.add(l+"-h"),n&2&&s.classList.add(l+"-s")),o()},ne=(e,t)=>"sc-"+e.$tagName$,J={},Pe="http://www.w3.org/2000/svg",Ie="http://www.w3.org/1999/xhtml",_e=e=>e!=null,H=e=>(e=typeof e,e==="object"||e==="function"),oe=(e,t,...s)=>{let n=null,o=!1,l=!1;const r=[],a=c=>{for(let $=0;$<c.length;$++)n=c[$],Array.isArray(n)?a(n):n!=null&&typeof n!="boolean"&&((o=typeof e!="function"&&!H(n))?n=String(n):typeof e!="function"&&n.$flags$===void 0&&O(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),o&&l?r[r.length-1].$text$+=n:r.push(o?_(null,n):n),l=o)};if(a(s),t){e==="input"&&De(t);{const c=t.className||t.class;c&&(t.class=typeof c!="object"?c:Object.keys(c).filter($=>c[$]).join(" "))}}if(r.some(w)&&O(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),typeof e=="function")return e(t===null?{}:t,r,je);const i=_(e,null);return i.$attrs$=t,r.length>0&&(i.$children$=r),i},_=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s},Oe={},w=e=>e&&e.$tag$===Oe,je={forEach:(e,t)=>e.map(X).forEach(t),map:(e,t)=>e.map(X).map(t).map(Ae)},X=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Ae=e=>{if(typeof e.vtag=="function"){const s=Object.assign({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),oe(e.vtag,s,...e.vchildren||[])}const t=_(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},De=e=>{const t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;const n=t.indexOf("type"),o=t.indexOf("min"),l=t.indexOf("max"),r=t.indexOf("step");(s<n||s<o||s<l||s<r)&&j('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},K=(e,t,s,n,o,l)=>{if(s!==n){let r=Z(e,t),a=t.toLowerCase();if(t==="class"){const i=e.classList,c=G(s),$=G(n);i.remove(...c.filter(d=>d&&!$.includes(d))),i.add(...$.filter(d=>d&&!c.includes(d)))}else if(t==="style"){for(const i in s)(!n||n[i]==null)&&(i.includes("-")?e.style.removeProperty(i):e.style[i]="");for(const i in n)(!s||n[i]!==s[i])&&(i.includes("-")?e.style.setProperty(i,n[i]):e.style[i]=n[i])}else if(!r&&t[0]==="o"&&t[1]==="n")t[2]==="-"?t=t.slice(3):Z(v,a)?t=a.slice(2):t=a[2]+t.slice(3),s&&f.rel(e,t,s,!1),n&&f.ael(e,t,n,!1);else{const i=H(n);if((r||i&&n!==null)&&!o)try{if(e.tagName.includes("-"))e[t]=n;else{const c=n==null?"":n;t==="list"?r=!1:(s==null||e[t]!=c)&&(e[t]=c)}}catch{}n==null||n===!1?(n!==!1||e.getAttribute(t)==="")&&e.removeAttribute(t):(!r||l&4||o)&&!i&&(n=n===!0?"":n,e.setAttribute(t,n))}}},Re=/\s/,G=e=>e?e.split(Re):[],re=(e,t,s,n)=>{const o=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||J,r=t.$attrs$||J;for(n in l)n in r||K(o,n,l[n],void 0,s,t.$flags$);for(n in r)K(o,n,l[n],r[n],s,t.$flags$)},U=(e,t,s,n)=>{const o=t.$children$[s];let l=0,r,a;if(o.$elm$&&O(`The JSX ${o.$text$!==null?`"${o.$text$}" text`:`"${o.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),o.$text$!==null)r=o.$elm$=h.createTextNode(o.$text$);else{if(u||(u=o.$tag$==="svg"),r=o.$elm$=h.createElementNS(u?Pe:Ie,o.$tag$),u&&o.$tag$==="foreignObject"&&(u=!1),re(null,o,u),_e(I)&&r["s-si"]!==I&&r.classList.add(r["s-si"]=I),o.$children$)for(l=0;l<o.$children$.length;++l)a=U(e,o,l),a&&r.appendChild(a);o.$tag$==="svg"?u=!1:r.tagName==="foreignObject"&&(u=!0)}return r},le=(e,t,s,n,o,l)=>{let r=e,a;for(r.shadowRoot&&r.tagName===D&&(r=r.shadowRoot);o<=l;++o)n[o]&&(a=U(null,s,o),a&&(n[o].$elm$=a,r.insertBefore(a,t)))},ie=(e,t,s,n,o)=>{for(;t<=s;++t)(n=e[t])&&(o=n.$elm$,o.remove())},we=(e,t,s,n)=>{let o=0,l=0,r=t.length-1,a=t[0],i=t[r],c=n.length-1,$=n[0],d=n[c],g;for(;o<=r&&l<=c;)a==null?a=t[++o]:i==null?i=t[--r]:$==null?$=n[++l]:d==null?d=n[--c]:P(a,$)?(k(a,$),a=t[++o],$=n[++l]):P(i,d)?(k(i,d),i=t[--r],d=n[--c]):P(a,d)?(k(a,d),e.insertBefore(a.$elm$,i.$elm$.nextSibling),a=t[++o],d=n[--c]):P(i,$)?(k(i,$),e.insertBefore(i.$elm$,a.$elm$),i=t[--r],$=n[++l]):(g=U(t&&t[l],s,l),$=n[++l],g&&a.$elm$.parentNode.insertBefore(g,a.$elm$));o>r?le(e,n[c+1]==null?null:n[c+1].$elm$,s,n,l,c):l>c&&ie(t,o,r)},P=(e,t)=>e.$tag$===t.$tag$,k=(e,t)=>{const s=t.$elm$=e.$elm$,n=e.$children$,o=t.$children$,l=t.$tag$,r=t.$text$;r===null?(u=l==="svg"?!0:l==="foreignObject"?!1:u,re(e,t,u),n!==null&&o!==null?we(s,n,t,o):o!==null?(e.$text$!==null&&(s.textContent=""),le(s,null,t,o,0,o.length-1)):n!==null&&ie(n,0,n.length-1),u&&l==="svg"&&(u=!1)):e.$text$!==r&&(s.data=r)},Ce=(e,t)=>{const s=e.$hostElement$;e.$cmpMeta$;const n=e.$vnode$||_(null,null),o=w(t)?t:oe(null,null,t);if(D=s.tagName,Array.isArray(t)&&t.some(w))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${D.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);o.$tag$=null,o.$flags$|=4,e.$vnode$=o,o.$elm$=n.$elm$=s.shadowRoot||s,I=s["s-sc"],k(n,o)},nt=e=>p(e).$hostElement$,He=(e,t,s)=>{const n=f.ce(t,s);return e.dispatchEvent(n),n},ae=(e,t)=>{t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},z=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}return ae(e,e.$ancestorComponent$),tt(()=>Ue(e,t))},Ue=(e,t)=>{e.$hostElement$;const s=m("scheduleUpdate",e.$cmpMeta$.$tagName$),n=e.$lazyInstance$;let o;return s(),qe(o,()=>ze(e,n,t))},ze=async(e,t,s)=>{const n=e.$hostElement$,o=m("update",e.$cmpMeta$.$tagName$),l=n["s-rc"];s&&Te(e);const r=m("render",e.$cmpMeta$.$tagName$);e.$flags$|=1024,Be(e,t,n),e.$renderCount$++,e.$flags$&=-1025,l&&(l.map(a=>a()),n["s-rc"]=void 0),r(),o();{const a=n["s-p"],i=()=>Me(e);a.length===0?i():(Promise.all(a).then(i),e.$flags$|=4,a.length=0)}},Be=(e,t,s)=>{try{Q=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(b.hasRenderFn||b.reflect)&&(b.vdomRender||b.reflect)&&(b.hydrateServerSide||Ce(e,t))}catch(a){x(a,e.$hostElement$)}return Q=null,null},Me=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=m("postUpdate",t);e.$lazyInstance$;const o=e.$ancestorComponent$;e.$flags$&64?n():(e.$flags$|=64,$e(s),n(),e.$onReadyResolve$(s),o||ce(t)),s["s-hmr-load"]&&s["s-hmr-load"](),e.$onInstanceResolve$(s),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&W(()=>z(e,!1)),e.$flags$&=-517},ce=e=>{$e(h.documentElement),W(()=>He(v,"appload",{detail:{namespace:N}})),performance.measure&&performance.measure(`[Stencil] ${N} initial load (by ${e})`,"st:app:start")},We=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(n){x(n)}},qe=(e,t)=>e&&e.then?e.then(t):t(),$e=e=>e.classList.add("hydrated"),Fe=(e,t)=>e!=null&&!H(e)&&t&1?String(e):e,Ne=(e,t)=>p(e).$instanceValues$.get(t),Qe=(e,t,s,n)=>{const o=p(e),l=o.$hostElement$,r=o.$instanceValues$.get(t),a=o.$flags$,i=o.$lazyInstance$;s=Fe(s,n.$members$[t][0]);const c=Number.isNaN(r)&&Number.isNaN(s),$=s!==r&&!c;(!(a&8)||r===void 0)&&$&&(o.$instanceValues$.set(t,s),o.$flags$&1024?j(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,l,`
New value`,s,`
Old value`,r):o.$flags$&2048&&j(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,l,`
New value`,s,`
Old value`,r),i&&(a&18)===2&&z(o,!1))},de=(e,t,s)=>{if(t.$members$){const n=Object.entries(t.$members$),o=e.prototype;if(n.map(([l,[r]])=>{r&31||s&2&&r&32?Object.defineProperty(o,l,{get(){return Ne(this,l)},set(a){{const i=p(this);(s&1)===0&&(i.$flags$&8)===0&&(r&31)!==0&&(r&1024)===0&&j(`@Prop() "${l}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}Qe(this,l,a,t)},configurable:!0,enumerable:!0}):s&1&&r&64&&Object.defineProperty(o,l,{value(...a){const i=p(this);return i.$onInstancePromise$.then(()=>i.$lazyInstance$[l](...a))}})}),s&1){const l=new Map;o.attributeChangedCallback=function(r,a,i){f.jmp(()=>{const c=l.get(r);if(this.hasOwnProperty(c))i=this[c],delete this[c];else if(o.hasOwnProperty(c)&&typeof this[c]=="number"&&this[c]==i)return;this[c]=i===null&&typeof this[c]=="boolean"?!1:i})},e.observedAttributes=n.filter(([r,a])=>a[0]&15).map(([r,a])=>{const i=a[1]||r;return l.set(i,r),i})}}return e},fe=async(e,t,s,n,o)=>{if((t.$flags$&32)===0){{if(t.$flags$|=32,o=Ve(s,t,n),o.then){const i=Le(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);o=await o,i()}if(!o)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);o.isProxied||(de(o,s,2),o.isProxied=!0);const a=m("createInstance",s.$tagName$);t.$flags$|=8;try{new o(t)}catch(i){x(i)}t.$flags$&=-9,a(),ue(t.$lazyInstance$)}if(o.style){let a=o.style;const i=ne(s,t.$modeName$);if(!A.has(i)){const c=m("registerStyles",s.$tagName$);ke(i,a,!!(s.$flags$&1)),c()}}}const l=t.$ancestorComponent$,r=()=>z(t,!0);l&&l["s-rc"]?l["s-rc"].push(r):r()},ue=e=>{We(e,"connectedCallback")},Ye=e=>{if((f.$flags$&1)===0){const t=p(e),s=t.$cmpMeta$,n=m("connectedCallback",s.$tagName$);if(t.$flags$&1)se(e,t,s.$listeners$),ue(t.$lazyInstance$);else{t.$flags$|=1;{let o=e;for(;o=o.parentNode||o.host;)if(o["s-p"]){ae(t,t.$ancestorComponent$=o);break}}s.$members$&&Object.entries(s.$members$).map(([o,[l]])=>{if(l&31&&e.hasOwnProperty(o)){const r=e[o];delete e[o],e[o]=r}}),fe(e,t,s)}n()}},Je=e=>{(f.$flags$&1)===0&&p(e).$lazyInstance$},Xe=(e,t,s)=>{const n=p(e);n.$flags$=1,e["s-hmr-load"]=()=>{delete e["s-hmr-load"]},fe(e,n,t,s)},Ke=(e,t={})=>{performance.mark&&performance.mark("st:app:start"),be();const s=m("bootstrapLazy"),n=[],o=t.exclude||[],l=v.customElements,r=h.head,a=r.querySelector("meta[charset]"),i=h.createElement("style"),c=[];let $,d=!0;Object.assign(f,t),f.$resourcesUrl$=new URL(t.resourcesUrl||"./",h.baseURI).href,e.map(g=>{g[1].map(L=>{const y={$flags$:L[0],$tagName$:L[1],$members$:L[2],$listeners$:L[3]};y.$members$=L[2];const T=y.$tagName$,q=class extends HTMLElement{constructor(E){super(E),E=this,Ge(E,y),y.$flags$&1&&E.attachShadow({mode:"open"})}connectedCallback(){$&&(clearTimeout($),$=null),d?c.push(this):f.jmp(()=>Ye(this))}disconnectedCallback(){f.jmp(()=>Je(this))}componentOnReady(){return p(this).$onReadyPromise$}};q.prototype["s-hmr"]=function(E){Xe(this,y,E)},y.$lazyBundleId$=g[0],!o.includes(T)&&!l.get(T)&&(n.push(T),l.define(T,de(q,y,1)))})}),i.innerHTML=n+Ee,i.setAttribute("data-styles",""),r.insertBefore(i,a?a.nextSibling:r.firstChild),d=!1,c.length?c.map(g=>g.connectedCallback()):f.jmp(()=>$=setTimeout(ce,30,"timeout")),s()},B=new WeakMap,p=e=>B.get(e),ot=(e,t)=>B.set(t.$lazyInstance$=e,t),Ge=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.$renderCount$=0,s.$onInstancePromise$=new Promise(n=>s.$onInstanceResolve$=n),s.$onReadyPromise$=new Promise(n=>s.$onReadyResolve$=n),e["s-p"]=[],e["s-rc"]=[],se(e,s,t.$listeners$),B.set(e,s)},Z=(e,t)=>t in e,x=(e,t)=>(0,console.error)(e,t),M=["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],O=(...e)=>console.error(...M,...e),j=(...e)=>console.warn(...M,...e),Ze=(...e)=>console.info(...M,...e),Ve=(e,t,s)=>{const n=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(typeof o!="string"){O(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}/*!__STENCIL_STATIC_IMPORT_SWITCH__*/return he(Object.assign({"./christmas-event.entry.js":()=>S(()=>import("./christmas-event.entry.c07f1486.js"),[]),"./christmas-letter.entry.js":()=>S(()=>import("./christmas-letter.entry.3a440f39.js"),[]),"./data-store.entry.js":()=>S(()=>import("./data-store.entry.64f02de9.js"),[]),"./event-dialog.entry.js":()=>S(()=>import("./event-dialog.entry.f1c1ea42.js"),[]),"./memory-wrapper.entry.js":()=>S(()=>import("./memory-wrapper.entry.d1c87571.js"),[])}),`./${o}.entry.js${s?"?s-hmr="+s:""}`).then(l=>l[n],x)},A=new Map,V=[],pe=[],et=(e,t)=>s=>{e.push(s),R||(R=!0,t&&f.$flags$&4?W(C):f.raf(C))},ee=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){x(s)}e.length=0},C=()=>{ee(V),ee(pe),(R=V.length>0)&&f.raf(C)},W=e=>te().then(e),tt=et(pe,!0),st=()=>{Ze("Running in development mode."),performance.mark||(performance.mark=performance.measure=()=>{},performance.getEntriesByName=()=>[]);const e=import.meta.url,t={};return e!==""&&(t.resourcesUrl=new URL(".",e).href),te(t)};st().then(e=>Ke([["memory-wrapper",[[0,"memory-wrapper",{data:[32]}]]],["christmas-letter",[[0,"christmas-letter",{data:[32]}]]],["data-store",[[1,"data-store",{listen:[64]}]]],["event-dialog",[[2,"event-dialog",{event:[1],clientWidth:[32]}]]],["christmas-event",[[0,"christmas-event",{ev:[16]}]]]],e));export{nt as g,oe as h,ot as r};
